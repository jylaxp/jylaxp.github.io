<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>AbstractQueuedSynchronizer</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="jylaxp">

<meta name="description" content="最近在看java.util.concurrent包下关于锁的代码，里面最核心的代码是AbstractQueuedSynchronizer.class这个类，阐述一下自己的理解。这里，我们抛开锁的概念，因为AbstractQueuedSynchronizer这个工具类是解决资源竞争问题的，锁只是资源..." />




  <meta name="keywords" itemprop="category" content="">


<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="AbstractQueuedSynchronizer">
<meta itemprop="description" content="最近在看java.util.concurrent包下关于锁的代码，里面最核心的代码是AbstractQueuedSynchronizer.class这个类，阐述一下自己的理解。这里，我们抛开锁的概念，因为AbstractQueuedSynchronizer这个工具类是解决资源竞争问题的，锁只是资源...">

  <meta itemprop="image" content="http://localhost:4000">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="AbstractQueuedSynchronizer">
<meta name="twitter:description" content="最近在看java.util.concurrent包下关于锁的代码，里面最核心的代码是AbstractQueuedSynchronizer.class这个类，阐述一下自己的理解。这里，我们抛开锁的概念，因为AbstractQueuedSynchronizer这个工具类是解决资源竞争问题的，锁只是资源...">



<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="http://localhost:4000">
  <meta property="twitter:image" content="http://localhost:4000">

<meta property="twitter:url" content="http://localhost:4000/java/2018/01/14/AbstractQueuedSynchronizer.html">

<!-- Open Graph data -->
<meta property="og:title" content="AbstractQueuedSynchronizer" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:4000/java/2018/01/14/AbstractQueuedSynchronizer.html" />

  <meta property="og:image" content="http://localhost:4000" />

<meta property="og:description" content="最近在看java.util.concurrent包下关于锁的代码，里面最核心的代码是AbstractQueuedSynchronizer.class这个类，阐述一下自己的理解。这里，我们抛开锁的概念，因为AbstractQueuedSynchronizer这个工具类是解决资源竞争问题的，锁只是资源..." />
<meta property="og:site_name" content="jylaxp's Blog" />

  <meta property="article:published_time" content="2018-01-14T00:00:00+08:00" />














  





  
    <meta property="article:tag" content="Java">
  



  <meta property="article:tag" content="">


    

    <link rel="canonical" href="http://localhost:4000/java/2018/01/14/AbstractQueuedSynchronizer.html">

    

    <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">jylaxp&#39;s Blog</a>
    

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
              
                <a class="page-link" href="/contact.html">Contact</a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">AbstractQueuedSynchronizer</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2018-01-14T00:00:00+08:00" itemprop="datePublished">
          
          Jan 14, 2018
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">jylaxp</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">AbstractQueuedSynchronizer</h1>
    <p class="post-meta">
      <time datetime="2018-01-14T00:00:00+08:00" itemprop="datePublished">
        
        Jan 14, 2018
      </time>
      </p>
  </header> -->

  <div itemprop="articleBody">
    <p>最近在看java.util.concurrent包下关于锁的代码，里面最核心的代码是AbstractQueuedSynchronizer.class这个类，阐述一下自己的理解。这里，我们抛开锁的概念，因为AbstractQueuedSynchronizer这个工具类是解决资源竞争问题的，锁只是资源的一种，而且AbstractQueuedSynchronizer也只是为资源竞争提供就解决框架，并不是解决具体场景的问题的。</p>

<h3 id="问题的场景">问题的场景</h3>
<p>两种模式:</p>

<ul>
  <li>独占模式，一次只能满足一个申请者</li>
  <li>共享模式，可以同时满足多个申请者</li>
</ul>

<p>接下来我们考虑申请资源会遇到哪些情况</p>

<ul>
  <li>资源池里有多少资源</li>
  <li>申请者希望申请多少个资源</li>
  <li>资源池里的资源不能满足当前申请者，该怎么办</li>
  <li>申请者申请资源时没有被满足，那后来资源能满足该申请者了，此时怎么办</li>
</ul>

<h3 id="代码分析">代码分析</h3>
<p>基于上面申请者申请资源会遇到的情况，我这里按资源类型分别分析代码。在开始分析之前，我们看一下关于”资源池”的定义和使用，资源池里的资源的使用方式和初始化数量，不同的场景有不同的使用方式，这个并不是统一一种方式，所以在这个框架里不会关心资源池和资源分配的事情，框架只关心申请者能不能被满足申请，如果不能被满足，框架要关心怎么处理申请者。</p>
<h4 id="独占模式">独占模式</h4>
<p><strong>申请资源</strong>
我们来看申请资源的代码(不响应中断模式)。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
		<span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>申请者(线程)调用acquire()方法申请arg个资源，首先会调用tryAcquire()方法尝试申请资源，该方法返回申请资源的结果－－成功或失败。如果申请资源成功，acquire()方法结束，申请者获得资源，可以干活了；如果失败，则调用acquireQueued()方法排队，等待申请的资源被满足。acquireQueued()方法的返回值是该线程在排队期间有没有被中断唤醒过(唤醒时会清除中断标示位)，当该线程(申请者)出队列时，如果排队期间被中断过，则设置线程的中断标示位。
这里申请资源时只是调用了tryAcquire()方法，这个方法是留给子类来解决具体的问题时覆盖重写的，也就说资源的管理和分配是给子类来实现的，框架并不关心这些，因此，这里我们不讨论资源是如何初始化和管理的，我们只关心申请结果。</p>

<p>我们来跟进addWaiter()方法，看一下它在干什么。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
	<span class="c1">// Try the fast path of enq; backup to full enq on failure</span>
	<span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
			<span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
			<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Node</span> <span class="nf">enq</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Must initialize</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetHead</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">()))</span>
				<span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">t</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
				<span class="k">return</span> <span class="n">t</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这里我们要先了解一下AQS框架的排队队列。这个队列是个双向队列，每个节点都是Node结构。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
	<span class="cm">/** 标记节点是共享模式 */</span>
	<span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">SHARED</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
	
	<span class="cm">/** 标记节点是独占模式 */</span>
	<span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">EXCLUSIVE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="cm">/** waitStatus的值，表示线程取消 */</span>
	<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span> <span class="o">=</span>  <span class="mi">1</span><span class="o">;</span>
	
	<span class="cm">/** waitStatus的值，表示线程需要唤醒 */</span>
	<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SIGNAL</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	
	<span class="cm">/** waitStatus的值，表示线程在等待唤醒条件 */</span>
	<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CONDITION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
	
	<span class="cm">/** waitStatus的值，在共享模式下使用 */</span>
	<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PROPAGATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">;</span>

	<span class="cm">/** Status field, taking on only the values:　 SIGNAL,   CANCELLED,   CONDITION,   PROPAGATE, 0　 */</span>
	<span class="kd">volatile</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">;</span>

	<span class="cm">/** 前一个节点*/</span>
	<span class="kd">volatile</span> <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span>

	<span class="cm">/**　后一个节点 */</span>
	<span class="kd">volatile</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

	<span class="cm">/**　线程 */</span>
	<span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">thread</span><span class="o">;</span>

	<span class="cm">/**　记录模式　 */</span>
	<span class="n">Node</span> <span class="n">nextWaiter</span><span class="o">;</span>

	<span class="cm">/**　是否是共享模式　 */</span>
	<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isShared</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">nextWaiter</span> <span class="o">==</span> <span class="n">SHARED</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="cm">/**　获取当前节点的前序节点　*/</span>
	<span class="kd">final</span> <span class="n">Node</span> <span class="nf">predecessor</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NullPointerException</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">p</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">Node</span><span class="o">()</span> <span class="o">{</span>    <span class="c1">// Used to establish initial head or SHARED marker</span>
	<span class="o">}</span>

	<span class="n">Node</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">,</span> <span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>     <span class="c1">// Used by addWaiter</span>
		<span class="k">this</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">mode</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">Node</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">,</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Used by Condition</span>
		<span class="k">this</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">=</span> <span class="n">waitStatus</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span> 
</code></pre></div></div>
<p>再看addWaiter()的代码。首先创建了一个Node，然后尝试入队。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
		<span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">node</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这里检查对尾是否为null,不为null则使用compareAndSetTail插入对尾。compareAndSetTail是原子操作，AQS框架都是使用CAS来保证原子操作的，这也是保证并发的关键点。如果tail为null或者入队失败，则调用enq()入队。enq()方法使用for循环，不断尝试将节点插入队列尾部，直到成功为止。在入队之前，检查了队列是否为空，如果为空，则设置一个dummy的头节点，此头节点仅仅标示是头，不包含线程。addWaiter()方法将节点入队之后，返回该节点，供acquireQueued()调度。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">try</span> <span class="o">{</span>
		<span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
			<span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
				<span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
				<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
				<span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
				<span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
			<span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>先看for循环里的逻辑。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
	<span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
	<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
	<span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>判断当前节点在队列中是不是第一节点，如果是第一个节点，则尝试申请资源。如果申请成功，则将该节点设置为头节点，返回中断标识。如果该节点不是第一个点或者该节点是第一个节点，但申请资源失败了，则调用shouldParkAfterFailedAcquire()判断是否需要挂起该节点，如果需要挂起该节点，则使用parkAndCheckInterrupt()方法挂起当前线程(节点里持有当前线程的引用)，至此，申请者把自己挂起了，等待被中断唤醒，然后继续执行。线程被唤醒之后设置了中断标示位，但是被唤醒不代表获取到资源，所以还需要再走一遍上面的逻辑，检查自己是否位于队列里第一个节点，获取资源等，如果不满足条件，则再次挂起自己，这个过程可能循环往复很多次，所以使用了for循环，直到其获得资源。我们看一下shouldParkAfterFailedAcquire()里判断是否需要挂起的逻辑。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 节点状态的取值有：</span>
	<span class="c1">// 0：</span>
	<span class="c1">// 1:申请取消, CANCELLED</span>
	<span class="c1">// -1: SIGNAL</span>
	<span class="c1">// -2: CONDITION</span>
	<span class="c1">// -3: PROPAGATE</span>
	<span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span>
		<span class="c1">// 前序节点的状态是SIGNAL，也就是前序节点在等待被唤醒</span>
		<span class="c1">// 意味着前序节点还有获取到资源，那么但节点是不可能获取到资源，需要挂起等待</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 前序节点的状态大于0，意思是前序接待被取消了，则向前遍历队列，将取消的节点从队列中去除</span>
		<span class="c1">// 完成该操作之后，node可能是位于队列中第一个节点，需要尝试获取资源，所以不能挂起</span>
		<span class="k">do</span> <span class="o">{</span>
			<span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
		<span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="c1">// 将前序节点设置为SIGNAL状态，不关心设置成功与否</span>
		<span class="c1">// 返回false，让外层的for循环再走一遍获取资源，判断是否需要挂起的逻辑</span>
		<span class="c1">// 可能会设置成功(为什么不是一定，自己想，不解释)</span>
		<span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>逻辑解释都写在了注释里，这里不啰嗦了。好，到此申请资源的代码分析结束。那么，这里的独占模式体现在哪里呢？请看官们对比共享模式思考。
<strong>释放资源</strong>
分析完了资源申请，接着分析资源释放。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
			<span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>资源是由子类来管理的，同资源申请，资源释放也应该由子类来释放，所以这里调用了tryRelease()来释放资源，tryRelease()同tryAcquire()，由子类根据其使用场景来重写覆盖。资源释放成功，判断头节点不为null，并且其状态不是0，如果满足条件则，unparkSuccessor()。这里要说明一点，头节点的状态，只有在初始化等待队时为0，此后不会再是0了(独占模式)。来看unparkSuccessor()。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unparkSuccessor</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">// 修改节点状态为0</span>
	<span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
		<span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

         <span class="c1">// 取该节点的后续节点</span>
	<span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	
	<span class="c1">// s == null 标示node节点可能已经被从队列中移除了</span>
	<span class="c1">// s.waitStatus &gt; 0　标示该节点取消了</span>
	<span class="c1">// 所以要从队尾向前遍历，找到最前面的需要唤醒的节点，为什么不从head向后遍历，取第一需要唤醒的节点，请自己思考</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">// 找到了待唤醒的节点，则唤醒该节点持有的线程</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
		<span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>释放资源的逻辑比较简单，当前线程释放玩资源，需要唤醒后一个排队的线程，否则，后续等待的线程就没有机会获取资源执行了。</p>

<p>分析完不响应中断模式，再来看响应中断模式，绝大部分逻辑是一样的，只是处理中断不一样，看你代码很容易理解。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
	<span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
		<span class="c1">// 如果申请资源时线程中断标示位已经置位，直接抛出InterruptedException</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
	<span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
		<span class="c1">// 申请资源失败</span>
		<span class="n">doAcquireInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
	<span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">);</span>
	<span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">try</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
			<span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
				<span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
				<span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
				<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
				<span class="k">return</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
				<span class="c1">// 线程中断过，唤醒时抛出InterruptedException</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
			<span class="c1">// 取消申请</span>
			<span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>代码和不响应中断的代码差不多，只不过在线程唤醒是检查了是佛有中断过，中断过就抛出InterruptedException异常，在finally把申请取消。</p>

<h4 id="共享模式">共享模式</h4>
<p><strong>申请资源</strong></p>

<p>我们来看申请资源的代码(不响应中断模式)。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
		<span class="c1">// 申请资源失败</span>
		<span class="n">doAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">SHARED</span><span class="o">);</span>
	<span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="k">try</span> <span class="o">{</span>
		<span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
			<span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
					<span class="c1">// 注意这行代码</span>
					<span class="n">setHeadAndPropagate</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
					<span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
					<span class="k">if</span> <span class="o">(</span><span class="n">interrupted</span><span class="o">)</span>
						<span class="n">selfInterrupt</span><span class="o">();</span>
					<span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
					<span class="k">return</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
				<span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
			<span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>共享模式和独占模式代码逻辑差不多，主要区别的在于<code class="highlighter-rouge">setHeadAndPropagate(node, r);</code>这行代码，独占模式是<code class="highlighter-rouge">setHead(node);</code>。共享模式，会在节点获得到起源之后会唤醒下个节点，也就是所谓的”传播”。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setHeadAndPropagate</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">propagate</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">// Record old head for check below</span>
	<span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
	<span class="cm">/*
         * Try to signal next queued node if:
         *   Propagation was indicated by caller,
         *     or was recorded (as h.waitStatus either before
         *     or after setHead) by a previous operation
         *     (note: this uses sign-check of waitStatus because
         *      PROPAGATE status may transition to SIGNAL.)
         * and
         *   The next node is waiting in shared mode,
         *     or we don't know, because it appears null
         *
         * The conservatism in both of these checks may cause
         * unnecessary wake-ups, but only when there are multiple
         * racing acquires/releases, so most need signals now or soon
         * anyway.
         */</span>
         <span class="c1">//　当剩余资源数大于0</span>
         <span class="c1">//  head == null 或者　(head != null 并且　h.waitStatus &lt; 0)</span>
         <span class="c1">// 这些情况下唤醒后续节点</span>
         <span class="c1">// 为什么有这些判断，特别是h.waitStatus &lt; 0，是为在队列里没有等待节时，不用向后传播，后续会把头节点的状态改成０</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">propagate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">isShared</span><span class="o">())</span>
			<span class="n">doReleaseShared</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在setHeadAndPropagate()方法中设置了head之后，判断剩余资源数和头节点的状态，决定是否唤醒后续节点。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doReleaseShared</span><span class="o">()</span> <span class="o">{</span>
	<span class="cm">/*
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         */</span>
	<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// 修改头节点状态</span>
				<span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
					<span class="k">continue</span><span class="o">;</span>            <span class="c1">// loop to recheck cases</span>
				<span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
					 <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">PROPAGATE</span><span class="o">))</span>
				<span class="k">continue</span><span class="o">;</span>                <span class="c1">// loop on failed CAS</span>
		<span class="o">}</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span>                   <span class="c1">// loop if head changed</span>
			<span class="k">break</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>释放资源</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">releaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseShared</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
		<span class="n">doReleaseShared</span><span class="o">();</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>调用tryReleaseShared()释放资源，释放成功，调用doReleaseShared()唤醒等待资源的线程。</p>


  </div>

  
</article>


      <footer class="site-footer">
        <!-- SVG icons from https://iconmonstr.com -->

        <!-- Github icon -->
        <span class="my-span-icon">
          <a href="https://github.com/jylaxp" aria-label="jylaxp's GitHub" title="jylaxp's GitHub">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
          </a>
        </span>

        <!-- Twitter icon
        <span class="my-span-icon">
          <a href="https://twitter.com/" aria-label="jylaxp's Twitter" title="jylaxp's Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>
 -->
        <!-- RSS icon -->
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact jylaxp">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        

      </footer>
    </section>

    
  </body>
</html>
